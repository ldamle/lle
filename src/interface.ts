import * as Types from './types';

// view
interface Scene {
    width: number,
    height: number
}

interface Diagramm {

}

interface Model {

}

interface Cell {

}

// controller

//=================================== interface Element ===================================//
interface Element {
    //----------------------------------- Element:setParams -----------------------------------//
    /**
     * * Задает параметры элемента: входы, выходы и сигналы.
     * Сигналы вводятся по очереди так: {{0,0,0,0},{1,1,0,0}}
     * Или используется механизм объединения по одному сигналу, 
     * а затем остальные недостающие вводятся по очереди: 
     * {{"E_n", 0, {0,0,0,0}}, {0,1,0,0}...}
     * @param inName Имена входов 
     * @param outName Имена выходов
     * @param signals Массив сигналов
     * Сигналы могут быть заданы последовательным перечислением или в группах. 
     * Особый случай: `"else"` — все необъявленные состояния принимают 
     * указанный массив сигналов при `signal = "x"`, при `signal = 0|1|"z"` 
     * все необъявленные состояния принимают `0|1|"z"` соответственно в не 
     * зависимости от массива.
     * Подробнее см. Типы:Сигналы.
     */
    setParams?(inName: string[], outName: string[], signals: Types.DSSSArray): Element;
    //----------------------------------- Element:setParams -----------------------------------//


    //----------------------------------- Element:concat -----------------------------------//
    /**
     * * Объединение двух элементов
     * Выходы первого элемента последовательно соединяются со входами второго 
     * при этом если у первого выходов больше чем у второго входов то выходы,
     * не соединенные со вторым элементом становятся выходами нового. Если у 
     * второго больше входов, то входы, не соедененные с первым элементом 
     * становятся входами нового.
     * @param elementOut Элемент, чьи выходы соединятся со входами
     * @param elementIn Элемент, чьи входы соединятся с выходами
     */
    concat?(elementOut: Element, elementIn: Element): Element;
    //----------------------------------- Element:concat -----------------------------------//


    //----------------------------------- Element:add -----------------------------------//
    /**
     * * Соеденяет текущий элемент с другим
     * Выходы первого элемента последовательно соединяются со входами второго 
     * при этом если у первого выходов больше чем у второго входов то выходы,
     * не соединенные со вторым элементом становятся выходами нового. Если у 
     * второго больше входов, то входы, не соедененные с первым элементом 
     * @param elementOut Элемент, чьи выходы соединятся со входами текущего
     * @returns connected element
     */
    add?(elementOut: Element): Element;
    //----------------------------------- Element:add -----------------------------------//


    //----------------------------------- Element:in -----------------------------------//
    /**
     * * Cоеденяет вход с названием name с заданным соединением
     * @param name Название входа, который необходимо соеденить
     * @param connection Соединение, имеющее выход с другим(или тем же самым) элементом
     * @returns Общее соединение
     */
    in?(name: string, connection: Connection): (Connection | string);
    //----------------------------------- Element:in -----------------------------------//


    //----------------------------------- Element:in -----------------------------------//
    /**
     * * Ищет вход с названием name
     * @param name Название входа
     * @returns Соединение, если вход соединен с выходом или название входа, если не подключен
     */
    in?(name: string): (Connection | string);
    //----------------------------------- Element:in -----------------------------------//

    //----------------------------------- Element:inIndex -----------------------------------//
    /**
     * * Ищет вход с названием name и возвращает его индекс
     * @param name Название входа
     * @returns Индекс в массиве in_connections
     */
    inIndex?(name: string): number;
    //----------------------------------- Element:inIndex -----------------------------------//

    //----------------------------------- Element:out -----------------------------------//
    /**
     * * Ищет выход с названием name
     * @param name Название выхода
     * @returns Соединение
     */
    out(name: string): Connection;
    //----------------------------------- Element:out -----------------------------------//


    //--------------------------------- Element:genState --------------------------------//
    /**
     * * Переводит упрощенную/полную форму записи сигнала в стандартную 
     * @param array Упрощенная/полная/стандартная форма записи
     * @returns Общая стандартная форма записи
     */
    genState?(array: Types.DSSSArray): Types.SignalArray[];
    //--------------------------------- Element:genState --------------------------------//

    //--------------------------------- Element:clone --------------------------------//
    /**
     * * Клонирует элемент вместе с подключениями
     * @returns Новый элемент -- копия this
     */
    clone(): Element;
    //--------------------------------- Element:clone --------------------------------//


    //--------------------------------- Element:isAllInConnected --------------------------------//
    /**
     * * Проверяет все ли входы подключены к выходам
     * @returns True если все входы подключены
     */
    isAllInConnected(): boolean;
    //--------------------------------- Element:isAllInConnected --------------------------------//


    //--------------------------------- Element:isAllSignalNotZ --------------------------------//
    /**
     * * Проверяет не находится ли ни один сигнал в разрывном состоянии
     * @returns True не находится ни один сигнал в разрывном состоянии
     */
    isAllSignalNotZ?(): boolean;
    //--------------------------------- Element:isAllSignalNotZ --------------------------------//


    //--------------------------------- Element:isReady --------------------------------//
    /**
     * * Проверяет готовность элемента к симуляции
     * @returns True если элемент готов к симуляции
     */
    isReady(): boolean;
    //--------------------------------- Element:isReady --------------------------------//


    //--------------------------------- Element:in_connections --------------------------------//
    /**
     * * Соединения/названия сигналов входа
     */
    in_connections?: (Connection | string)[];
    //--------------------------------- Element:in_connections ---------------------------


    //--------------------------------- Element:out_connections --------------------------------//
    /**
     * * Соединения сигналов выхода
     */
    out_connections: Connection[];
    //--------------------------------- Element:out_connections --------------------------------//


    //--------------------------------- Element:state --------------------------------//
    /**
     * * Массив состояний
     */
    state?: Types.SignalArray[];
    //--------------------------------- Element:state --------------------------------//


    //--------------------------------- Element:name --------------------------------//
    /**
     * * Имя элемента
     */
    name?: string;
    //--------------------------------- Element:name --------------------------------//
}
//=================================== interface Element ===================================//


//=================================== interface Connection ===================================//
interface Connection {
    //--------------------------------- Connection:inConnect --------------------------------//
    /**
     * * Присоеденияет соединение ко входу
     * @param inSource Вход соединения
     * @returns Соединение
     */
    inConnect(inSource: Types.Sources): Connection;
    //--------------------------------- Connection:inConnect --------------------------------//


    //--------------------------------- Connection:disConnect --------------------------------//
    /**
     * * Отсоединяет соединение от входа
     * @param inSource Вход соединения
     * @returns Соединение
     */
    disConnect(inSource: Types.Sources): Connection;
    //--------------------------------- Connection:disConnect --------------------------------//


    //--------------------------------- Connection:inConnects --------------------------------//
    /**
     * * Присоеденияет соединение ко входам
     * @param inSourceArray Массив входов соединения
     * @returns Соединение
     */
    inConnects(inSourceArray: Types.SourcesArray): Connection;
    //--------------------------------- Connection:inConnects --------------------------------//


    //--------------------------------- Connection:disConnects --------------------------------//
    /**
     * * Отсоединяет соединение от входов
     * @param inSourceArray Массив входов соединения
     * @returns Соединение
     */
    disConnects(inSourceArray: Types.SourcesArray): Connection;
    //--------------------------------- Connection:disConnects --------------------------------//


    //--------------------------------- Connection:lenInConnected --------------------------------//
    /**
     * * Количество соединенных входов
     * @returns Количество
     */
    lenInConnected(): number;
    //--------------------------------- Connection:lenInConnected --------------------------------//


    //--------------------------------- Connection:clone --------------------------------//
    /**
     * * Клонирует подключения
     * @param element Элемент, чьи выходы теперь будут
     * @returns Новый элемент -- копия this
     */
    clone(element: Element): Connection;
    //--------------------------------- Connection:clone --------------------------------//


    //--------------------------------- Connection:getArrayInString --------------------------------//
    /**
     * * Возвращает массив входов в виде строки
     * @returns массив входов в виде строки
     */
    getArrayInString(): string[];
    //--------------------------------- Connection:getArrayInString --------------------------------//     

    //--------------------------------- Connection:getArrayInString --------------------------------//
    /**
     * * Находит вход по элементу
     * @param element Элемент, чей вход мы ищем
     * @returns массив входов в виде строки
     */
    findInString(element: Element): string;
    //--------------------------------- Connection:getArrayInString --------------------------------// 

    //--------------------------------- Connection:isConnected --------------------------------//
    /**
     * * Проверяет наличие соединения
     * @returns True если есть соединение
     */
    isConnected(): boolean;
    //--------------------------------- Connection:isConnected --------------------------------//


    //--------------------------------- Connection:in --------------------------------//
    /**
     * * Массив входов соединения
     */
    in: (Types.SourcesArray | false);
    //--------------------------------- Connection:in --------------------------------//


    //--------------------------------- Connection:out --------------------------------//
    /**
     * * Выход соединения
     */
    readonly out: Types.Sources;
    //--------------------------------- Connection:out --------------------------------//
}
//=================================== interface Connection ===================================//


//=================================== interface Model ===================================//
interface Model {
    //--------------------------------- Model:generators --------------------------------//
    /**
     * * Массив генераторов для моделирования
     */
    generators: Element[];
    //--------------------------------- Model:generators --------------------------------//


    //--------------------------------- Model:elements_array --------------------------------//
    /**
     * * Массив всех элементов, учавствующих в моделировании
     */
    elements_array: Element[];
    //--------------------------------- Model:elements_array --------------------------------//


    //--------------------------------- Model:time --------------------------------//
    /**
     * * Объект времени, содержащий текущее время, частоту, начало/конец моделирования и конец паттерна
     */
    time: {
        now: number;              // Текущее время
        freq: number;             // Частота
        begin: number;            // Начало временного интервала
        end: number;              // Конец временного интервала
        pattern_end: number;      // Конец паттерна
    };
    //--------------------------------- Model:time --------------------------------//


    //--------------------------------- Model:model_table --------------------------------//
    /**
     * * Таблица-результат моделирования, содержащий информацию о времени, генераторах и элементах
     */
    model_table: {
        t: number;                // Время
        generators: Types.SignalArray;   // Сигналы генераторов
        elements: Types.SignalArray[];   // Сигналы элементов
    }[];
    //--------------------------------- Model:model_table --------------------------------//


    //--------------------------------- Model:autoFreq --------------------------------//
    /**
     * * Автоматически устанавливает частоту моделирования по частотам генераторов
     */
    autoFreq(): void;
    //--------------------------------- Model:autoFreq --------------------------------//


    //--------------------------------- Model:autoPatternEnd --------------------------------//
    /**
     * * Автоматически устанавливает конец паттерна (наверное с триггерами плохо будет работать)
     */
    autoPatternEnd(): void;
    //--------------------------------- Model:autoPatternEnd --------------------------------//


    //--------------------------------- Model:modelNext --------------------------------//
    /**
     * * Переходит к следующему такту, записывая поведение всех элементов текущего
     */
    modelNext(): void;
    //--------------------------------- Model:modelNext --------------------------------//


    //--------------------------------- Model:modelPattern --------------------------------//
    /**
     * * Моделируем весь паттерн до конца
     */
    modelPattern(): void;
    //--------------------------------- Model:modelPattern --------------------------------//


    //--------------------------------- Model:modelAll --------------------------------//
    /**
     * * Моделируем все до конца
     */
    modelAll(): void;
    //--------------------------------- Model:modelAll --------------------------------//


    //--------------------------------- Model:deleteNowModel --------------------------------//
    /**
     * * Удаляет текущий такт и его состояние модели. Может быть полезно при изменении входов-выходов.
     */
    deleteNowModel(): void;
    //--------------------------------- Model:deleteNowModel --------------------------------//


    //--------------------------------- Model:deleteModel --------------------------------//
    /**
     * * Удаляет все моделирование
     */
    deleteModel(): void;
    //--------------------------------- Model:deleteModel --------------------------------//


    //--------------------------------- Model:remodelNow --------------------------------//
    /**
     * * Удаляет и еще раз выполняет текущий такт
     */
    remodelNow(): void;
    //--------------------------------- Model:remodelNow --------------------------------//


    //--------------------------------- Model:remodelAll --------------------------------//
    /**
     * * Удаляет все отмоделированное и еще раз выполняет
     */
    remodelAll(): void;
    //--------------------------------- Model:remodelAll --------------------------------//


    //--------------------------------- Model:findOutput --------------------------------//
    /**
     * * Находит выход по соединению
     * @param out Соединение
     * @returns Массив сигналов для данного соединения
     */
    findOutput(out: Connection): Types.SignalArray;
    //--------------------------------- Model:findOutput --------------------------------//


    //--------------------------------- Model:findOutputT --------------------------------//
    /**
     * * Находит выход по соединению с указанием времени
     * @param out Соединение
     * @returns Массив объектов, содержащих время и сигнал
     */
    findOutputT(out: Connection): {t: number, signal: Types.Signal}[];
    //--------------------------------- Model:findOutputT --------------------------------//


    //--------------------------------- Model:findOutputs --------------------------------//
    /**
     * * Находит все выходы по соединению
     * @param out Соединение
     * @returns Массив массивов сигналов для данного соединения
     */
    findOutputs(out: Connection): Types.SignalArray[];
    //--------------------------------- Model:findOutputs --------------------------------//


    //--------------------------------- Model:findOutputsT --------------------------------//
    /**
     * * Находит все выходы по соединению с указанием времени
     * @param out Соединение
     * @returns Массив объектов, содержащих время и массив сигналов
     */
    findOutputsT(out: Connection): {t: number, signals: Types.Signal[]}[];
    //--------------------------------- Model:findOutputsT --------------------------------//
}
//=================================== interface Model ===================================//


//=================================== interface ElementGraph ===================================//
interface ElementGraph {
    //--------------------------------- ElementGraph:tree --------------------------------//
    /**
     * * Граф элементов
     */
    tree: Types.ElementGraphNode[];
    //--------------------------------- ElementGraph:tree --------------------------------//

    //--------------------------------- ElementGraph:genTree --------------------------------//
    /**
     * * Генерируем граф элементов
     */
    genGraph(pointElement:Element): void;
    //--------------------------------- ElementGraph:genTree --------------------------------//


    //--------------------------------- ElementGraph:findElement --------------------------------//
    /**
     * * Находим элемент в графе
     */
    findElement(pointElement: Element): (Types.ElementGraphNode|false);
    //--------------------------------- ElementGraph:findElement --------------------------------//

    //--------------------------------- ElementGraph:getOutputs --------------------------------//
    /**
     * * Возвращает массив выходов, которые ни к чему не подключены
     * @returns Массив соединений
     */
    getOutputs(): Connection[];
    //--------------------------------- ElementGraph:getOutputs --------------------------------//

    //--------------------------------- ElementGraph:getOutputs --------------------------------//
    /**
     * * Возвращает массив входов, которые ни к чему не подключены
     * @returns Массив соединений
     */
    getInputs(): Connection[];
    //--------------------------------- ElementGraph:getOutputs --------------------------------//


    //--------------------------------- ElementGraph:getGenerators --------------------------------//
    /**
     * * Возвращает массив генераторов
     * @returns Массив генераторов
     */
    getGenerators(): Element[];
    //--------------------------------- ElementGraph:getGenerators --------------------------------//

    //--------------------------------- ElementGraph:getAllElementsDFS --------------------------------//
    /**
     * * Возвращает обход графа в глубину
     * @returns Массив элементов дерева
     */
    getAllElementsDFS(): Element[];
    //--------------------------------- ElementGraph:getAllElementsDFS --------------------------------//

    //--------------------------------- ElementGraph:getAllElementsBFS --------------------------------//
    /**
     * * Возвращает обход графа в ширину
     * @returns Массив элементов дерева
     */
    getAllElementsBFS(): Element[];
    //--------------------------------- ElementGraph:getAllElementsBFS --------------------------------//

    //--------------------------------- ElementGraph:getAllNodeDFS --------------------------------//
    /**
     * * Возвращает ноды обхода графа в глубину 
     * @returns Массив нод графа
     */
    getAllNodeDFS(): Types.ElementGraphNode[];
    //--------------------------------- ElementGraph:getAllNodeDFS --------------------------------//

    //--------------------------------- ElementGraph:getAllNodeBFS --------------------------------//
    /**
     * * Возвращает ноды обхода графа в ширину
     * @returns Массив нод графа
     */
    getAllNodeBFS(): Types.ElementGraphNode[];
    //--------------------------------- ElementGraph:getAllNodeBFS --------------------------------//


    //--------------------------------- ElementGraph:getSetNodeDFS --------------------------------//
    /**
     * * Возвращает уникальные ноды обхода графа в грубину
     * @returns Массив нод графа 
     */
    getSetNodeDFS(): Types.ElementGraphNode[];
    //--------------------------------- ElementGraph:getSetNodeDFS --------------------------------//

    //--------------------------------- ElementGraph:getSetNodeBFS --------------------------------//
    /**
     * * Возвращает уникальные ноды обхода графа в ширину
     * @returns Массив нод графа
     */
    getSetNodeBFS(): Types.ElementGraphNode[];
    //--------------------------------- ElementGraph:getSetNodeBFS --------------------------------//
}
//=================================== interface ElementGraph ===================================//


export { Scene, Diagramm, Model, Cell, Element, Connection, ElementGraph };