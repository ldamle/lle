import * as Types from './types';

// view
interface Scene {
    width: number,
    height: number
}

// interface Diagramm {

// }

// interface Cell {

// }

// controller

//=================================== interface Element ===================================//
interface Element {
    //----------------------------------- Element:setParams -----------------------------------//
    /**
     * * Устанавливает параметры элемента: входы, выходы и сигналы.
     * Сигналы могут задаваться последовательно, например: {{0,0,0,0},{1,1,0,0}}
     * Или можно использовать механизм частичного задания: сначала вводится
     * один сигнал, затем остальные недостающие вводятся по порядку:
     * {{"E_n", 0, {0,0,0,0}}, {0,1,0,0}...}
     * @param inName Имена входов
     * @param outName Имена выходов
     * @param signals Массив сигналов
     * Сигналы могут быть заданы последовательным перечислением или группами.
     * Особый случай: `"else"` — все необъявленные состояния принимают
     * указанный массив сигналов при `signal = "x"`, при `signal = 0|1|"z"`
     * все необъявленные состояния принимают `0|1|"z"` соответственно, независимо от массива.
     * Подробнее см. Типы: Сигналы.
     */
    setParams?(inName: string[], outName: string[], signals: Types.DSSSArray): Element;
    //----------------------------------- Element:setParams -----------------------------------//


    //----------------------------------- Element:concat -----------------------------------//
    /**
     * * Объединение двух элементов
     * Выходы первого элемента последовательно соединяются со входами второго.
     * Если у первого элемента больше выходов, чем у второго входов, то
     * неиспользованные выходы становятся выходами нового элемента.
     * Если у второго элемента больше входов, чем выходов у первого, неиспользованные
     * входы становятся входами нового элемента.
     * @param elementOut Элемент, чьи выходы будут соединены с входами
     * @param elementIn Элемент, чьи входы будут соединены с выходами
     */
    concat?(elementOut: Element, elementIn: Element): Element;
    //----------------------------------- Element:concat -----------------------------------//


    //----------------------------------- Element:add -----------------------------------//
    /**
     * * Подключает текущий элемент к другому
     * Выходы первого элемента последовательно соединяются со входами второго.
     * Если у первого элемента больше выходов, чем у второго входов, неиспользованные
     * выходы становятся выходами нового элемента. Если у второго элемента
     * больше входов, то неиспользованные входы становятся входами нового элемента.
     * @param elementOut Элемент, чьи выходы соединяются с входами текущего
     * @returns соединенный элемент
     */
    add?(elementOut: Element): Element;
    //----------------------------------- Element:add -----------------------------------//


    //----------------------------------- Element:in -----------------------------------//
    /**
     * * Подключает вход с заданным именем к соединению
     * @param name Имя входа, который нужно подключить
     * @param connection Соединение с выходом другого (или того же) элемента
     * @returns Общее соединение
     */
    in?(name: string, connection: Connection): (Connection | string);
    //----------------------------------- Element:in -----------------------------------//


    //----------------------------------- Element:in -----------------------------------//
    /**
     * * Ищет вход с заданным именем
     * @param name Имя входа
     * @returns Соединение, если вход подключен, или имя входа, если не подключен
     */
    in?(name: string): (Connection | string);
    //----------------------------------- Element:in -----------------------------------//


    //----------------------------------- Element:inIndex -----------------------------------//
    /**
     * * Ищет вход с заданным именем и возвращает его индекс
     * @param name Имя входа
     * @returns Индекс в массиве in_connections
     */
    inIndex?(name: string): number;
    //----------------------------------- Element:inIndex -----------------------------------//


    //----------------------------------- Element:out -----------------------------------//
    /**
     * * Ищет выход с заданным именем
     * @param name Имя выхода
     * @returns Соединение
     */
    out(name: string): Connection;
    //----------------------------------- Element:out -----------------------------------//


    //--------------------------------- Element:genState --------------------------------//
    /**
     * * Преобразует упрощенную/полную форму записи сигнала в стандартную
     * @param array Упрощенная/полная/стандартная форма записи
     * @returns Стандартная форма записи сигнала
     */
    genState?(array: Types.DSSSArray): Types.SignalArray[];
    //--------------------------------- Element:genState --------------------------------//


    //--------------------------------- Element:clone --------------------------------//
    /**
     * * Клонирует элемент вместе с подключениями
     * @returns Новый элемент -- копия текущего
     */
    clone(): Element;
    //--------------------------------- Element:clone --------------------------------//


    //--------------------------------- Element:isAllInConnected --------------------------------//
    /**
     * * Проверяет, подключены ли все входы
     * @returns True, если все входы подключены
     */
    isAllInConnected(): boolean;
    //--------------------------------- Element:isAllInConnected --------------------------------//


    //--------------------------------- Element:isAllSignalNotZ --------------------------------//
    /**
     * * Проверяет, находится ли хотя бы один сигнал в неопределенном состоянии
     * @returns True, если ни один сигнал не находится в неопределенном состоянии
     */
    isAllSignalNotZ?(): boolean;
    //--------------------------------- Element:isAllSignalNotZ --------------------------------//


    //--------------------------------- Element:isReady --------------------------------//
    /**
     * * Проверяет готовность элемента к симуляции
     * @returns True, если элемент готов к симуляции
     */
    isReady(): boolean;
    //--------------------------------- Element:isReady --------------------------------//


    //--------------------------------- Element:in_connections --------------------------------//
    /**
     * * Соединения/названия сигналов входа
     */
    in_connections?: (Connection | string)[];
    //--------------------------------- Element:in_connections ---------------------------


    //--------------------------------- Element:out_connections --------------------------------//
    /**
     * * Соединения сигналов выхода
     */
    out_connections: Connection[];
    //--------------------------------- Element:out_connections --------------------------------//


    //--------------------------------- Element:state --------------------------------//
    /**
     * * Массив состояний сигнала
     */
    state?: Types.SignalArray[];
    //--------------------------------- Element:state --------------------------------//


    //--------------------------------- Element:name --------------------------------//
    /**
     * * Имя элемента
     */
    name?: string;
    //--------------------------------- Element:name --------------------------------//
}
//=================================== interface Element ===================================//

//=================================== interface Connection ===================================//
interface Connection {
    //--------------------------------- Connection:inConnect --------------------------------//
    /**
     * * Подключает соединение ко входу
     * @param inSource Вход соединения
     * @returns Соединение
     */
    inConnect(inSource: Types.Sources): Connection;
    //--------------------------------- Connection:inConnect --------------------------------//


    //--------------------------------- Connection:disConnect --------------------------------//
    /**
     * * Отключает соединение от входа
     * @param inSource Вход соединения
     * @returns Соединение
     */
    disConnect(inSource: Types.Sources): Connection;
    //--------------------------------- Connection:disConnect --------------------------------//


    //--------------------------------- Connection:inConnects --------------------------------//
    /**
     * * Подключает соединение ко множеству входов
     * @param inSourceArray Массив входов соединения
     * @returns Соединение
     */
    inConnects(inSourceArray: Types.SourcesArray): Connection;
    //--------------------------------- Connection:inConnects --------------------------------//


    //--------------------------------- Connection:disConnects --------------------------------//
    /**
     * * Отключает соединение от множественных входов
     * @param inSourceArray Массив входов соединения
     * @returns Соединение
     */
    disConnects(inSourceArray: Types.SourcesArray): Connection;
    //--------------------------------- Connection:disConnects --------------------------------//


    //--------------------------------- Connection:lenInConnected --------------------------------//
    /**
     * * Возвращает количество подключенных входов
     * @returns Количество подключенных входов
     */
    lenInConnected(): number;
    //--------------------------------- Connection:lenInConnected --------------------------------//


    //--------------------------------- Connection:clone --------------------------------//
    /**
     * * Клонирует текущее соединение с новыми элементами
     * @param element Элемент, к которому будет подключено новое соединение
     * @returns Новое соединение с клонированными входами
     */
    clone(element: Element): Connection;
    //--------------------------------- Connection:clone --------------------------------//


    //--------------------------------- Connection:getArrayInString --------------------------------//
    /**
     * * Возвращает массив входов в виде строковых значений
     * @returns Массив строк, представляющих входы
     */
    getArrayInString(): string[];
    //--------------------------------- Connection:getArrayInString --------------------------------//


    //--------------------------------- Connection:findInString --------------------------------//
    /**
     * * Находит строковое представление входа по элементу
     * @param element Элемент, для которого нужно найти подключенный вход
     * @returns Название входа
     */
    findInString(element: Element): string;
    //--------------------------------- Connection:findInString --------------------------------//


    //--------------------------------- Connection:isConnected --------------------------------//
    /**
     * * Проверяет, подключено ли соединение хотя бы к одному входу
     * @returns True, если хотя бы один вход подключен
     */
    isConnected(): boolean;
    //--------------------------------- Connection:isConnected --------------------------------//


    //--------------------------------- Connection:in --------------------------------//
    /**
     * * Массив подключенных входов или false, если входы отсутствуют
     */
    in: (Types.SourcesArray | false);
    //--------------------------------- Connection:in --------------------------------//


    //--------------------------------- Connection:out --------------------------------//
    /**
     * * Выход соединения (только для чтения)
     */
    readonly out: Types.Sources;
    //--------------------------------- Connection:out --------------------------------//
}
//=================================== interface Connection ===================================//


//=================================== interface Model ===================================//
interface Model {
    //--------------------------------- Model:generators --------------------------------//
    /**
     * * Массив генераторов для моделирования
     */
    generators: Element[];
    //--------------------------------- Model:generators --------------------------------//


    //--------------------------------- Model:elements_array --------------------------------//
    /**
     * * Массив всех элементов, учавствующих в моделировании
     */
    elements_array: Element[];
    //--------------------------------- Model:elements_array --------------------------------//


    //--------------------------------- Model:time --------------------------------//
    /**
     * * Объект времени, содержащий текущее время, частоту, начало/конец моделирования и конец паттерна
     */
    time: {
        now: number;              // Текущее время
        freq: number;             // Частота
        begin: number;            // Начало временного интервала
        end: number;              // Конец временного интервала
        pattern_end: number;      // Конец паттерна
    };
    //--------------------------------- Model:time --------------------------------//


    //--------------------------------- Model:model_table --------------------------------//
    /**
     * * Таблица-результат моделирования, содержащий информацию о времени, генераторах и элементах
     */
    model_table: {
        t: number;                // Время
        generators: Types.SignalArray;   // Сигналы генераторов
        elements: Types.SignalArray[];   // Сигналы элементов
    }[];
    //--------------------------------- Model:model_table --------------------------------//


    //--------------------------------- Model:autoFreq --------------------------------//
    /**
     * * Автоматически устанавливает частоту моделирования по частотам генераторов
     */
    autoFreq(): void;
    //--------------------------------- Model:autoFreq --------------------------------//


    //--------------------------------- Model:autoPatternEnd --------------------------------//
    /**
     * * Автоматически устанавливает конец паттерна (наверное с триггерами плохо будет работать)
     */
    autoPatternEnd(): void;
    //--------------------------------- Model:autoPatternEnd --------------------------------//


    //--------------------------------- Model:modelNext --------------------------------//
    /**
     * * Переходит к следующему такту, записывая поведение всех элементов текущего
     */
    modelNext(): void;
    //--------------------------------- Model:modelNext --------------------------------//


    //--------------------------------- Model:modelPattern --------------------------------//
    /**
     * * Моделируем весь паттерн до конца
     */
    modelPattern(): void;
    //--------------------------------- Model:modelPattern --------------------------------//


    //--------------------------------- Model:modelAll --------------------------------//
    /**
     * * Моделируем все до конца
     */
    modelAll(): void;
    //--------------------------------- Model:modelAll --------------------------------//


    //--------------------------------- Model:deleteNowModel --------------------------------//
    /**
     * * Удаляет текущий такт и его состояние модели. Может быть полезно при изменении входов-выходов.
     */
    deleteNowModel(): void;
    //--------------------------------- Model:deleteNowModel --------------------------------//


    //--------------------------------- Model:deleteModel --------------------------------//
    /**
     * * Удаляет все моделирование
     */
    deleteModel(): void;
    //--------------------------------- Model:deleteModel --------------------------------//


    //--------------------------------- Model:remodelNow --------------------------------//
    /**
     * * Удаляет и еще раз выполняет текущий такт
     */
    remodelNow(): void;
    //--------------------------------- Model:remodelNow --------------------------------//


    //--------------------------------- Model:remodelAll --------------------------------//
    /**
     * * Удаляет все отмоделированное и еще раз выполняет
     */
    remodelAll(): void;
    //--------------------------------- Model:remodelAll --------------------------------//


    //--------------------------------- Model:findOutput --------------------------------//
    /**
     * * Находит выход по соединению
     * @param out Соединение
     * @returns Массив сигналов для данного соединения
     */
    findOutput(out: Connection): Types.SignalArray;
    //--------------------------------- Model:findOutput --------------------------------//


    //--------------------------------- Model:findOutputT --------------------------------//
    /**
     * * Находит выход по соединению с указанием времени
     * @param out Соединение
     * @returns Массив объектов, содержащих время и сигнал
     */
    findOutputT(out: Connection): { t: number, signal: Types.Signal }[];
    //--------------------------------- Model:findOutputT --------------------------------//


    //--------------------------------- Model:findOutputs --------------------------------//
    /**
     * * Находит все выходы по соединению
     * @param out Соединение
     * @returns Массив массивов сигналов для данного соединения
     */
    findOutputs(out: Connection): Types.SignalArray[];
    //--------------------------------- Model:findOutputs --------------------------------//


    //--------------------------------- Model:findOutputsT --------------------------------//
    /**
     * * Находит все выходы по соединению с указанием времени
     * @param out Соединение
     * @returns Массив объектов, содержащих время и массив сигналов
     */
    findOutputsT(out: Connection): { t: number, signals: Types.Signal[] }[];
    //--------------------------------- Model:findOutputsT --------------------------------//
}
//=================================== interface Model ===================================//


//=================================== interface ElementGraph ===================================//
/**
 * Интерфейс для создания и управления графом элементов.
 * Обеспечивает методы для генерации графа, поиска элементов, получения информации о подключённых и неподключённых соединениях,
 * а также выполнения обхода графа различными способами.
 */
interface ElementGraph {
    //--------------------------------- ElementGraph:tree --------------------------------//
    /**
     * * Граф элементов, представленный в виде массива узлов графа.
     * Каждый узел описывает элемент и его связи в графе.
     */
    tree: Types.ElementGraphNode[];
    //--------------------------------- ElementGraph:tree --------------------------------//

    //--------------------------------- ElementGraph:genGraph --------------------------------//
    /**
     * * Генерирует граф элементов начиная с указанного элемента.
     * @param pointElement - Начальный элемент для генерации графа.
     */
    genGraph(pointElement: Element): void;
    //--------------------------------- ElementGraph:genGraph --------------------------------//

    //--------------------------------- ElementGraph:findElement --------------------------------//
    /**
     * * Находит элемент в графе.
     * Возвращает узел графа, связанный с указанным элементом, или `false`, если элемент не найден.
     * @param pointElement - Элемент, который нужно найти в графе.
     * @returns Узел графа или `false`, если элемент не найден.
     */
    findElement(pointElement: Element): (Types.ElementGraphNode | false);
    //--------------------------------- ElementGraph:findElement --------------------------------//

    //--------------------------------- ElementGraph:getOutputs --------------------------------//
    /**
     * * Возвращает массив выходных соединений, которые ни к чему не подключены.
     * Это может быть полезно для анализа недостающих связей в графе.
     * @returns Массив незадействованных выходных соединений.
     */
    getOutputs(): Connection[];
    //--------------------------------- ElementGraph:getOutputs --------------------------------//

    //--------------------------------- ElementGraph:getInputs --------------------------------//
    /**
     * * Возвращает массив входных соединений, которые ни к чему не подключены.
     * Это может помочь в поиске недостающих входных соединений в графе.
     * @returns Массив незадействованных входных соединений.
     */
    getInputs(): Connection[];
    //--------------------------------- ElementGraph:getInputs --------------------------------//

    //--------------------------------- ElementGraph:getGenerators --------------------------------//
    /**
     * * Возвращает массив генераторов, которые присутствуют в графе.
     * Генераторы — это элементы, создающие сигнал (например, генераторы меандра).
     * @returns Массив элементов-генераторов.
     */
    getGenerators(): Element[];
    //--------------------------------- ElementGraph:getGenerators --------------------------------//

    //--------------------------------- ElementGraph:getAllElementsDFS --------------------------------//
    /**
     * * Возвращает все элементы графа, используя алгоритм обхода в глубину (DFS).
     * Элементы возвращаются в порядке обхода.
     * @returns Массив элементов, отсортированный по результатам обхода в глубину.
     */
    getAllElementsDFS(): Element[];
    //--------------------------------- ElementGraph:getAllElementsDFS --------------------------------//

    //--------------------------------- ElementGraph:getAllElementsBFS --------------------------------//
    /**
     * * Возвращает все элементы графа, используя алгоритм обхода в ширину (BFS).
     * Элементы возвращаются в порядке обхода.
     * @returns Массив элементов, отсортированный по результатам обхода в ширину.
     */
    getAllElementsBFS(): Element[];
    //--------------------------------- ElementGraph:getAllElementsBFS --------------------------------//

    //--------------------------------- ElementGraph:getAllNodeDFS --------------------------------//
    /**
     * * Возвращает все узлы графа, используя алгоритм обхода в глубину (DFS).
     * Узлы содержат элементы и их соединения.
     * @returns Массив узлов графа, отсортированный по результатам обхода в глубину.
     */
    getAllNodeDFS(): Types.ElementGraphNode[];
    //--------------------------------- ElementGraph:getAllNodeDFS --------------------------------//

    //--------------------------------- ElementGraph:getAllNodeBFS --------------------------------//
    /**
     * * Возвращает узлы графа с уникальными элементами, используя алгоритм обхода в ширину (BFS).
     * Алгоритм устроен не совсем так как у обычного дерева: если все элементы,
     * к которым подключен текущий анализируемый элемент уже есть в массиве то
     * элемент подключается. Это позволяет избежать при симуляциях неизвестных значений
     * и симулировать все элементы по порядку.
     * Узлы содержат элементы и их соединения.
     * @returns Массив узлов графа, отсортированный по результатам обхода в ширину.
     */
    getAllNodeBFS(): Types.ElementGraphNode[];
    //--------------------------------- ElementGraph:getAllNodeBFS --------------------------------//

    //--------------------------------- ElementGraph:getSetNodeDFS --------------------------------//
    /**
     * * Возвращает уникальные узлы графа, используя алгоритм обхода в глубину (DFS).
     * Уникальные узлы — это узлы, которые встречаются в графе только один раз.
     * @returns Массив уникальных узлов графа, отсортированных по результатам обхода в глубину.
     */
    getSetNodeDFS(): Types.ElementGraphNode[];
    //--------------------------------- ElementGraph:getSetNodeDFS --------------------------------//

}
//=================================== interface ElementGraph ===================================//



export {
    Scene,
    // Diagramm,
    Model,
    // Cell,
    Element,
    Connection,
    ElementGraph
};
